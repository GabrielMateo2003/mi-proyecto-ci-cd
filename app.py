# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IbFV-mImlazUt6m_Re8afr95H7cqvIch
"""

# =================================================================
# IMPORTACIÓN DE LIBRERÍAS Y DATASET
# =================================================================
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import confusion_matrix, classification_report, accuracy_score, roc_curve, auc
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense

url = 'https://raw.githubusercontent.com/shivang98/Social-Network-ads-Boost/master/Social_Network_Ads.csv'
dataset = pd.read_csv(url)

# Selección de variables (Edad y Salario Estimado)
X = dataset.iloc[:, [2, 3]].values
y = dataset.iloc[:, -1].values

# División de datos (80% entrenamiento, 20% test)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.20, random_state = 0)

# Escalado de características (Vital para KNN y Redes Neuronales)
sc = StandardScaler()
X_train = sc.fit_transform(X_train)
X_test = sc.transform(X_test)

# =================================================================
#  IMPLEMENTACIÓN DE KNN
# =================================================================
knn_classifier = KNeighborsClassifier(n_neighbors = 5, metric = 'minkowski', p = 2)
knn_classifier.fit(X_train, y_train)
y_pred_knn = knn_classifier.predict(X_test)
y_prob_knn = knn_classifier.predict_proba(X_test)[:, 1]

# =================================================================
# IMPLEMENTACIÓN DE RED NEURONAL ARTIFICIAL (ANN)
# =================================================================
ann = Sequential([
    Dense(units=6, activation='relu', input_shape=(X_train.shape[1],)),
    Dense(units=6, activation='relu'),
    Dense(units=1, activation='sigmoid')
])

ann.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
ann.fit(X_train, y_train, batch_size=32, epochs=100, verbose=0)

y_prob_ann = ann.predict(X_test).ravel()
y_pred_ann = (y_prob_ann > 0.5).astype(int)

# =================================================================
# MATRICES DE CONFUSIÓN Y MÉTRICAS
# =================================================================
def plot_evaluation(y_true, y_pred, title):
    cm = confusion_matrix(y_true, y_pred)
    plt.figure(figsize=(5,4))
    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues')
    plt.title(f'Matriz de Confusión - {title}')
    plt.ylabel('Real')
    plt.xlabel('Predicho')
    plt.show()
    print(f"--- Reporte de Clasificación: {title} ---")
    print(classification_report(y_true, y_pred))

plot_evaluation(y_test, y_pred_knn, "KNN")
plot_evaluation(y_test, y_pred_ann, "Red Neuronal")

# =================================================================
# CURVA ROC Y COMPARATIVO
# =================================================================
fpr_knn, tpr_knn, _ = roc_curve(y_test, y_prob_knn)
roc_auc_knn = auc(fpr_knn, tpr_knn)

fpr_ann, tpr_ann, _ = roc_curve(y_test, y_prob_ann)
roc_auc_ann = auc(fpr_ann, tpr_ann)

plt.figure(figsize=(8, 6))
plt.plot(fpr_knn, tpr_knn, color='blue', label=f'KNN (AUC = {roc_auc_knn:.2f})')
plt.plot(fpr_ann, tpr_ann, color='red', label=f'ANN (AUC = {roc_auc_ann:.2f})')
plt.plot([0, 1], [0, 1], color='gray', linestyle='--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('Tasa de Falsos Positivos (FPR)')
plt.ylabel('Tasa de Verdaderos Positivos (TPR)')
plt.title('Comparativo de Curvas ROC')
plt.legend(loc="lower right")
plt.grid(alpha=0.3)
plt.show()